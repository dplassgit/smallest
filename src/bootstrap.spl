;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SPL Compiler written in SPL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

true=1
false=0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input

;ainput%20 j=0
;ainput[j]='$ j=j+1
;ainput[j]='' j=j+1
;ainput[j]='y j=j+1
ainput@


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; LEXER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Token types
EOF=0
CONST=1
VAR=2
SYM=3 ; symbol/keyword
ERROR=4
CHARCONST=5

;; Symbols/Keywords
PRINTCH='$
PRINTINT='#
IF='?
ELSE=':
WHILE='~
RETURN='^
AND='&
OR='|
LENGTH='%
PLUS='+
MINUS='-
MULT='*
EQ='=
NEQ='!
LT='<
INPUT='@
OPENPAREN='(
CLOSEPAREN=')
OPENBRACKET='[
CLOSEBRACKET=']
PROCDEF='_
STOP='\

NUMSYMBOLS=22
aSYMBOLS%NUMSYMBOLS j=0
aSYMBOLS[j]=PRINTCH j=j+1
aSYMBOLS[j]=PRINTINT j=j+1
aSYMBOLS[j]=IF j=j+1
aSYMBOLS[j]=ELSE j=j+1
aSYMBOLS[j]=WHILE j=j+1
aSYMBOLS[j]=RETURN j=j+1
aSYMBOLS[j]=AND j=j+1
aSYMBOLS[j]=OR j=j+1
aSYMBOLS[j]=LENGTH j=j+1
aSYMBOLS[j]=PLUS j=j+1
aSYMBOLS[j]=MINUS j=j+1
aSYMBOLS[j]=MULT j=j+1
aSYMBOLS[j]=EQ j=j+1
aSYMBOLS[j]=NEQ j=j+1
aSYMBOLS[j]=LT j=j+1
aSYMBOLS[j]=OPENPAREN j=j+1
aSYMBOLS[j]=CLOSEPAREN j=j+1
aSYMBOLS[j]=OPENBRACKET j=j+1
aSYMBOLS[j]=CLOSEBRACKET j=j+1
aSYMBOLS[j]=PROCDEF j=j+1
aSYMBOLS[j]=INPUT j=j+1
aSYMBOLS[j]=STOP j=j+1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Table of strings for printing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

as%1000 j=0 HEADER=0
as[j]='; j=j+1
as[j]=32 j=j+1
as[j]='s j=j+1
as[j]='p j=j+1
as[j]='l j=j+1
as[j]=10 j=j+1
as[j]='g j=j+1
as[j]='l j=j+1
as[j]='o j=j+1
as[j]='b j=j+1
as[j]='a j=j+1
as[j]='l j=j+1
as[j]=32 j=j+1 MAIN=j
as[j]='m j=j+1
as[j]='a j=j+1
as[j]='i j=j+1
as[j]='n j=j+2 SECTION=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='c j=j+1
as[j]='t j=j+1
as[j]='i j=j+1
as[j]='o j=j+1
as[j]='n j=j+2 DOTTEXT=j
as[j]='. j=j+1
as[j]='t j=j+1
as[j]='e j=j+1
as[j]='x j=j+1
as[j]='t j=j+2 DOTDATA=j
as[j]='. j=j+1
as[j]='d j=j+1
as[j]='a j=j+1
as[j]='t j=j+1
as[j]='a j=j+2 BAD=j
as[j]='B j=j+1
as[j]='a j=j+1
as[j]='d j=j+2 TOKEN=j
as[j]='t j=j+1
as[j]='o j=j+1
as[j]='k j=j+1
as[j]='e j=j+1
as[j]='n j=j+2 SYMBOL=j
as[j]='s j=j+1
as[j]='y j=j+1
as[j]='m j=j+1
as[j]='b j=j+1
as[j]='o j=j+1
as[j]='l j=j+2 INTFMT=j
as[j]='I j=j+1
as[j]='N j=j+1
as[j]='T j=j+1
as[j]='_ j=j+1
as[j]='F j=j+1
as[j]='M j=j+1
as[j]='T j=j+1 INTEND=j
as[j]=': j=j+1
as[j]='d j=j+1
as[j]='b j=j+1
as[j]='' j=j+1
as[j]='% j=j+1
as[j]='d j=j+1
as[j]='' j=j+1
as[j]=', j=j+1
as[j]='0 j=j+2 INTFMTEND=j EXTERN=j
as[j]='e j=j+1
as[j]='x j=j+1
as[j]='t j=j+1
as[j]='e j=j+1
as[j]='r j=j+1
as[j]='n j=j+2 SUB=j
as[j]='s j=j+1
as[j]='u j=j+1
as[j]='b j=j+2 RSP=j
as[j]='R j=j+1
as[j]='S j=j+1
as[j]='P j=j+1
as[j]=', j=j+1
as[j]='3 j=j+1
as[j]='2 j=j+2 ADD=j
as[j]='a j=j+1
as[j]='d j=j+1
as[j]='d j=j+2 CALL=j
as[j]='c j=j+1
as[j]='a j=j+1
as[j]='l j=j+1
as[j]='l j=j+2 PUTCHAR=j
as[j]='p j=j+1
as[j]='u j=j+1
as[j]='t j=j+1
as[j]='c j=j+1
as[j]='h j=j+1
as[j]='a j=j+1
as[j]='r j=j+2 EXIT=j
as[j]='e j=j+1
as[j]='x j=j+1
as[j]='i j=j+1
as[j]='t j=j+2 PRINTF=j
as[j]='p j=j+1
as[j]='r j=j+1
as[j]='i j=j+1
as[j]='n j=j+1
as[j]='t j=j+1
as[j]='f j=j+2 GLOBALDD=j ; :dd 0
as[j]=': j=j+1
as[j]='d j=j+1
as[j]='d j=j+1
as[j]=32 j=j+1
as[j]='0 j=j+2 EXPECTED=j
as[j]='E j=j+1
as[j]='x j=j+1
as[j]='p j=j+1
as[j]='e j=j+1
as[j]='c j=j+1
as[j]='t j=j+1
as[j]='e j=j+1
as[j]='d j=j+2 PUSH=j
as[j]='p j=j+1
as[j]='u j=j+1
as[j]='s j=j+1
as[j]='h j=j+2 POP=j
as[j]='p j=j+1
as[j]='o j=j+1
as[j]='p j=j+2 IMUL=j
as[j]='i j=j+1
as[j]='m j=j+1
as[j]='u j=j+1
as[j]='l j=j+2 CMP=j
as[j]='c j=j+1
as[j]='m j=j+1
as[j]='p j=j+2 SETZ=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='t j=j+1
as[j]='z j=j+2 SETL=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='t j=j+1
as[j]='l j=j+2 JMP=j
as[j]='j j=j+1
as[j]='m j=j+1
as[j]='p j=j+2 ALCOMMAZERO=j
as[j]='A j=j+1
as[j]='L j=j+1
as[j]=', j=j+1
as[j]='0 j=j+2 SETNZ=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='t j=j+1
as[j]='n j=j+1
as[j]='z j=j+2 ANDOP=j
as[j]='a j=j+1
as[j]='n j=j+1
as[j]='d j=j+2 OROP=j
as[j]='o j=j+1
as[j]='r j=j+2 XCHG=j
as[j]='x j=j+1
as[j]='c j=j+1
as[j]='h j=j+1
as[j]='g j=j+2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_ printbetween(amsg start end) (
  i=start ~(amsg[i]!0 & i<end) ( $amsg[i] i=i+1 )
  $32
)

; Print one
_ pone(start) (
  printbetween(as start 9999999)
)
_ printbw(start end) (
  printbetween(as start end)
)

; Print string from s to 0
_ printstr(amsg s) (
  printbetween(amsg s 99999999)
)

; Print two strings
_ ptwo(first second) (
  pone(first) pone(second)
)

; Print the given token (for debugging)
_ printToken(at) (
  ? (at[0]=CONST) ( $'c $': $32 printstr(at 1) )
  ? (at[0]=VAR) ( $'v $': $32 printstr(at 1) )
  ? (at[0]=SYM) ( $'s $': $32 $at[1])
  ? (at[0]=ERROR) ( $'!)
  ? (at[0]=EOF) ( $'$)
  $10
)

_ fail(at) (
  ptwo(BAD TOKEN) $': $32 printToken(at)
  \ ; exit now
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Lexer globals
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

loc=0   ; index into text
cc=0  ; current char

_ vadvanceLexer() (
   ? (ainput[loc]!0) ( cc=ainput[loc] )
   : ( cc=0 )
   loc=loc+1
)

_ isNumber(c) (
  ^ (('0-1)<c & c<('9+1))
)

_ isAlpha(c) (
  ? (('a-1)<c & c<('z+1)) (^true)
  ? (('A-1)<c & c<('Z+1)) (^true)
  ^false
)

_ aMakeNumber() (
  at%20
  at[0] = CONST
  at[1] = cc
  i = 2
  vadvanceLexer()
  ~ (cc!0 & isNumber(cc)=true & i<20) (
    at[i] = cc
    i = i + 1
    vadvanceLexer()
  )
  ^at
)

_ aMakeCharConstant() (
  at%3
  vadvanceLexer()  ; skip the tick
  at[0] = CHARCONST
  at[1] = cc
  vadvanceLexer()  ; eat the character
  ^at
)

_ aMakeText() (
  at%20
  at[0] = VAR
  at[1] = cc
  i = 2
  vadvanceLexer()
  ~ (cc!0 & isAlpha(cc)=true & i<20) (
    at[i] = cc
    i = i + 1
    vadvanceLexer()
  )
  ^at
)

_ aMakeSymbol() (
  at%2
  at[0] = SYM
  i=0
  ~ (i < NUMSYMBOLS) ( ; & aSYMBOLS[i]!0) (
    ? (aSYMBOLS[i]=cc) ( ; found it
      at[1]=cc
      vadvanceLexer()
      ^at
    )
    i=i+1
  )
  ptwo(BAD SYMBOL) $': $cc $32 $'( #cc $')
  \ ; exit
)

_ skipWhitespace() (
  more=true
  ~ (more=true) (
    ~ (cc=10|cc=13|cc=32|cc=8) (vadvanceLexer()) ; whitespace
    ? (cc=';) (
       ; skip comment until EOL
       ~ (cc!10 & cc!0) (vadvanceLexer())
    )
    : (more=false)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; returns array of (up to) 20 ints
; 0 has type: end of file, constant (int), variable, keyword, symbol
; 1 if keyword or symbol: the character
; 1 through 19: variable or constant value (0-terminated)
_ aNextToken() (
  skipWhitespace()
  ? (cc=0) ( at%1 at[0]=EOF ^at) ; end of file
  ? (isNumber(cc)=true) ( ^aMakeNumber() )
  ? (isAlpha(cc)=true) ( ^aMakeText() )
  ? (cc=39) ( ^aMakeCharConstant() )
  ^aMakeSymbol()
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Debugging
;_ printtokens() (
;  vadvanceLexer()
;
;  atemptoken = aNextToken()
;  printToken(atemptoken)
;
;  ~ (atemptoken[0]!EOF) (
;    atemptoken = aNextToken()
;    printToken(atemptoken)
;  )
;)
;printtokens() \


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PARSER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; Current token
atoken%1 ; this allocation will get thrown away


id=0
_ nextLabel() (
  id=id+1
  ^ id
)

_ vadvance() (
  atoken = aNextToken()
  $'; $32 printToken(atoken)
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Print helpers

; Print variable with the given offset. 0 offset=global
_ printVar(avarname offset) (
  ? (offset=0) ( $'[ $'_ printstr(avarname 0) $'])
  : ($'p $'v fail(atoken))
)


_ call(start) (
  ptwo(CALL start) $10
)

_ emitExtern(function) (
 ; extern (function)
 ptwo(EXTERN function) $10
 ; sub rsp, 32
 ptwo(SUB RSP) $10
 call(function)
 ; add rsp, 32
 ptwo(ADD RSP) $10
)

_ emitLabel(labelid)  (
  $'L #labelid $': $10
)


; Copy the value of the token into a new array.
_ acopyValue() (
  i=0 ~(atoken[i+1]!0) (i=i+1)
  adest%(i+1)
  i=1 ~(atoken[i]!0 & i<20) (adest[i-1]=atoken[i] i=i+1)
  ^adest
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Registers

RAX=0 RBX=1 RCX=2 RDX=3
EAX=4 EBX=5 ECX=6 EDX=7

_ reg(index) (
  ? (index<EAX) ( $'R $(index+'A))
  : ( $'E $((index-EAX)+'A))
  $'X
)

_ mov() ( $'m $'o $'v $32 )

_ xfer(dest src) (
  mov() reg(dest) $', reg(src) $10
)

_ push(register) (
  pone(PUSH) reg(register) $10
)

_ pop(register) (
  pone(POP) reg(register) $10
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Var types
VARTYPEINT=1
VARTYPEARR=2


_ expectSymbol(s) (
  ? (isSymbol(s)=true) ( vadvance() )
  : ( pone(EXPECTED) $s $32 $'s $'a $'w $32 $atoken[1] $10 fail(atoken))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Expression parsing

_ parseAtom() (
  ? (atoken[0]=CONST) (
    mov() reg(EAX) $', printstr(atoken 1) $10

    vadvance()
    ^VARTYPEINT
  )

  ? (atoken[0]=CHARCONST) (
    ; print as a number
    mov() reg(EAX) $', #(atoken[1]) $10

    vadvance()
    ^VARTYPEINT
  )
  ? (atoken[0]=VAR) (
    avar = acopyValue()
    vadvance()
    ; TODO: if [ do array dereference
    ; TODO: if ( do function call
    ; TODO: infer variable type and use RAX if array
    mov() reg(EAX) $', printVar(avar 0) $10
    ^VARTYPEINT
  )

  ? (isSymbol(OPENPAREN)) (
    expectSymbol(OPENPAREN)
    varType = expr()
    expectSymbol(CLOSEPAREN)
    ^varType
  )

  : ( $'a $'t $'o $'m fail(atoken) )
  ^0
)

_ isSymbol(s) (
  ^(atoken[0]=SYM & atoken[1]=s)
)

_ rhs(op leftType) (
  pop(RBX)
  ? (op=PLUS) ( pone(ADD) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=MULT) ( pone(IMUL) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=AND) ( pone(ANDOP) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=OR) ( pone(OROP) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=EQ) (
    ; cmp EBX, EAX
    ; setz AL
    ; and rax, 15
    pone(CMP) reg(EBX) $', reg(EAX) $10
    pone(SETZ) $'A $'L $10
    pone(ANDOP) reg(EAX) $', #15 $10
    ^leftType
  )
  ? (op=NEQ) (
    ; cmp EBX, EAX
    ; setnz AL
    ; and rax, 15
    pone(CMP) reg(EBX) $', reg(EAX) $10
    pone(SETNZ) $'A $'L $10
    pone(ANDOP) reg(EAX) $', #15 $10
    ^leftType
  )
  ? (op=LT) (
    ; cmp EBX, EAX
    ; setl AL
    ; and rax, 15
    pone(CMP) reg(EBX) $', reg(EAX) $10
    pone(SETL) $'A $'L $10
    pone(ANDOP) reg(EAX) $', #15 $10
    ^leftType
  )
  ? (op=MINUS) (
    ; xchg EAX, EBX
    ; sub EAX, EBX
    pone(XCHG) reg(EAX) $', reg(EBX) $10
    pone(SUB) reg(EAX) $', reg(EBX) $10
    ^leftType
  )
  $'U $'n ptwo(EXPECTED SYMBOL) $op $10 fail(atoken)
)

aPREC%8 j=0
aPREC[j]=MULT j=j+1
aPREC[j]=MINUS j=j+1
aPREC[j]=PLUS j=j+1
aPREC[j]=LT j=j+1
aPREC[j]=NEQ j=j+1
aPREC[j]=EQ j=j+1
aPREC[j]=AND j=j+1
aPREC[j]=OR

_ exprLevel(level) (
  ? (level<0) ( ^parseAtom() )
  leftType = exprLevel(level-1)
  op = aPREC[level]
  ~ (isSymbol(op)) (
    vadvance()
    push(RAX)
    rightType = exprLevel(level - 1)
    rhs(op leftType)
  )
  ^leftType
)

_ expr() (
  ^exprLevel(7)
)


;; Data segment
aDATA%1000 ndata=0 ; # of bytes of data
intFmtAdded=false

;; Hash codes of global data names
aHASHES%100 nhashes=0

_ vaddData(asource start end) (
  i=start
  ~ (i<end & asource[i]!0) (aDATA[ndata]=asource[i] i=i+1 ndata=ndata+1)
  aDATA[ndata]=10 ndata=ndata+1
)

aPRIMES%10
aPRIMES[0]=73
aPRIMES[1]=179
aPRIMES[2]=283
aPRIMES[3]=419
aPRIMES[4]=547
aPRIMES[5]=31
aPRIMES[6]=131
aPRIMES[7]=239
aPRIMES[8]=359
aPRIMES[9]=479

_ hash(astring) (
  i=0 pi=0 ; prime index
  r=137 ; result
  ~ (astring[i]!0) (
    r=r*101+astring[i]*aPRIMES[pi]
    pi=pi+1
    ?(pi=10) (pi=0)
    i=i+1
  )
  ^r
)

_ globalExists(aname) (
  thehash=hash(aname)
  i=0 ~(i<nhashes) (
    ?(aHASHES[i]=thehash) (^true) ; found
    i=i+1
  )
  ; not found, add to the end
  aHASHES[nhashes]=thehash
  nhashes=nhashes+1
  ^false
)


; Add a global with the given name and type (int or array)
_ vaddGlobal(aname type) (
  ? (globalExists(aname)=false) (
    ; add _(name)
    aDATA[ndata]='_ ndata=ndata+1
    i=0 ~(aname[i]!0) (aDATA[ndata]=aname[i] i=i+1 ndata=ndata+1)

    ; add :dd 0 TODO If array use dq not dd
    vaddData(as GLOBALDD 99999999)
  )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parse statements

_ parsePrint() (
  printch = (atoken[1]=PRINTCH)
  vadvance()   ; eat the character

  type = expr() ; ignoring return type for now.

  ? (printch=true) (
    xfer(ECX EAX)
    emitExtern(PUTCHAR)
  )
  : (
    ; add data INT_FMT: db '%d', 0
    ~ (intFmtAdded=false) (
      vaddData(as INTFMT INTFMTEND)
      intFmtAdded=true
    )
    ; mov RCX, INT_FMT
    mov() reg(RCX) $', printbw(INTFMT INTEND) $10
    ; mov edx, eax
    xfer(EDX EAX)

    emitExtern(PRINTF)
  )
  ^0
)

_ parseStop() (
  vadvance()
  call(EXIT)
  ^0
)

_ parseIf() (
  expectSymbol(IF)
  exprType = expr()

  elseLabel = nextLabel()
  endIfLabel = nextLabel()

  ; cmp al, 0
  ptwo(CMP ALCOMMAZERO) $10
  ; je Lelselabel
  $'j $'e $32 $'L #elseLabel $10

  expectSymbol(OPENPAREN)
  ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
    statement()
  )
  expectSymbol(CLOSEPAREN)
  hasElse = isSymbol(ELSE)
  ? (hasElse) (
    pone(JMP) $'L #endIfLabel $10
  )
  emitLabel(elseLabel)

  ? (hasElse) (
    expectSymbol(ELSE)
    expectSymbol(OPENPAREN)
    ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
      statement()
    )
    expectSymbol(CLOSEPAREN)
    emitLabel(endIfLabel)
  )
)

_ parseWhile() (
  expectSymbol(WHILE)

  startLabel = nextLabel()
  endLabel = nextLabel()
  emitLabel(startLabel)

  stopType = expr() ; TODO: check type

  ; cmp al, 0
  ptwo(CMP ALCOMMAZERO) $10
  ; je Llabel
  $'j $'e $32 $'L #endLabel $10

  expectSymbol(OPENPAREN)
  ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
    statement()
  )
  expectSymbol(CLOSEPAREN)

  ; jmp Lend
  pone(JMP) $'L #startLabel $10
  emitLabel(endLabel)
)


_ startsWithSymbol() (
  ? ( atoken[1]=IF) ( ^parseIf() )
  ? ( atoken[1]=PRINTCH | atoken[1]=PRINTINT) ( ^parsePrint() )
  ? ( atoken[1]=STOP) ( ^parseStop() )
  ? ( atoken[1]=WHILE) ( ^parseWhile() )

  ; TODO ^ ret
  ; TODO _ define proc
  $'s $'w $'s fail(atoken)
)


_ parseAssign(avarname) (
  vadvance() ; eat the =
  expr()
  ; TODO: get the offset of this variable
  vaddGlobal(avarname 0)
  mov() printVar(avarname 0) $', reg(EAX) $10
)


_ startsWithVar() (
  aname=acopyValue()
  vadvance()
  ? (atoken[0]=SYM & atoken[1]='=) (parseAssign(aname))
  ; TODO: if ( do function call
  ; TODO: if [ do array set
)


_ statement() (
  ? (atoken[0]=SYM) ( ^startsWithSymbol() )
  ? (atoken[0]=VAR) ( ^startsWithVar() )
  ? (atoken[0]=EOF) ( ^0 )
  $'s fail(atoken)
)


_ statements() (
  ~ (atoken[0]!EOF) (
    statement()
  )
)

_ parse() (
  ; $'; printstr(ainput 0)

  vadvanceLexer() ; prime the lexer
  vadvance() ; prime the parser

  ; global main
  printstr(as HEADER) $10
  ; section .text
  ptwo(SECTION DOTTEXT) $10

  printstr(as MAIN) $': $10

  statements()

  ; call exit
  emitExtern(EXIT)
  ; ret
  $'r $'e $'t $10

  ? (ndata!0) (
    $10
    ; section .data
    ptwo(SECTION DOTDATA) $10
    printstr(aDATA 0)
  )
)

parse()

