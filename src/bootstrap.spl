;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SPL Compiler written in SPL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

true=1
false=0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input

;ainput%20 j=0
;ainput[j]='$ j=j+1
;ainput[j]='' j=j+1
;ainput[j]='y j=j+1
ainput@


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; LEXER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Token types
EOF=0
CONST=1
VAR=2
SYM=3 ; symbol/keyword
ERROR=4
CHARCONST=5

;; Symbols/Keywords
PRINTCH='$
PRINTINT='#
IF='?
ELSE=':
WHILE='~
RETURN='^
AND='&
OR='|
LENGTH='%
PLUS='+
MINUS='-
MULT='*
EQ='=
NEQ='!
LT='<
INPUT='@
OPENPAREN='(
CLOSEPAREN=')
OPENBRACKET='[
CLOSEBRACKET=']
PROCDEF='_
STOP='\

NUMSYMBOLS=22
aSYMBOLS%NUMSYMBOLS j=0
aSYMBOLS[j]=PRINTCH j=j+1
aSYMBOLS[j]=PRINTINT j=j+1
aSYMBOLS[j]=IF j=j+1
aSYMBOLS[j]=ELSE j=j+1
aSYMBOLS[j]=WHILE j=j+1
aSYMBOLS[j]=RETURN j=j+1
aSYMBOLS[j]=AND j=j+1
aSYMBOLS[j]=OR j=j+1
aSYMBOLS[j]=LENGTH j=j+1
aSYMBOLS[j]=PLUS j=j+1
aSYMBOLS[j]=MINUS j=j+1
aSYMBOLS[j]=MULT j=j+1
aSYMBOLS[j]=EQ j=j+1
aSYMBOLS[j]=NEQ j=j+1
aSYMBOLS[j]=LT j=j+1
aSYMBOLS[j]=OPENPAREN j=j+1
aSYMBOLS[j]=CLOSEPAREN j=j+1
aSYMBOLS[j]=OPENBRACKET j=j+1
aSYMBOLS[j]=CLOSEBRACKET j=j+1
aSYMBOLS[j]=PROCDEF j=j+1
aSYMBOLS[j]=INPUT j=j+1
aSYMBOLS[j]=STOP j=j+1


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Table of strings for printing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

as%1000 j=0 HEADER=0
as[j]='; j=j+1
as[j]=32 j=j+1
as[j]='s j=j+1
as[j]='p j=j+1
as[j]='l j=j+1
as[j]=10 j=j+1
as[j]='g j=j+1
as[j]='l j=j+1
as[j]='o j=j+1
as[j]='b j=j+1
as[j]='a j=j+1
as[j]='l j=j+1
as[j]=32 j=j+1 MAIN=j
as[j]='m j=j+1
as[j]='a j=j+1
as[j]='i j=j+1
as[j]='n j=j+2 SECTION=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='c j=j+1
as[j]='t j=j+1
as[j]='i j=j+1
as[j]='o j=j+1
as[j]='n j=j+2 DOTTEXT=j
as[j]='. j=j+1
as[j]='t j=j+1
as[j]='e j=j+1
as[j]='x j=j+1
as[j]='t j=j+2 DOTDATA=j
as[j]='. j=j+1
as[j]='d j=j+1
as[j]='a j=j+1
as[j]='t j=j+1
as[j]='a j=j+2 BAD=j
as[j]='B j=j+1
as[j]='a j=j+1
as[j]='d j=j+2 TOKEN=j
as[j]='t j=j+1
as[j]='o j=j+1
as[j]='k j=j+1
as[j]='e j=j+1
as[j]='n j=j+2 SYMBOL=j
as[j]='s j=j+1
as[j]='y j=j+1
as[j]='m j=j+1
as[j]='b j=j+1
as[j]='o j=j+1
as[j]='l j=j+2 INTFMT=j
as[j]='I j=j+1
as[j]='N j=j+1
as[j]='T j=j+1
as[j]='_ j=j+1
as[j]='F j=j+1
as[j]='M j=j+1
as[j]='T j=j+1 INTEND=j
as[j]=': j=j+1
as[j]='d j=j+1
as[j]='b j=j+1
as[j]='' j=j+1
as[j]='% j=j+1
as[j]='d j=j+1
as[j]='' j=j+1
as[j]=', j=j+1
as[j]='0 j=j+2 INTFMTEND=j EXTERN=j
as[j]='e j=j+1
as[j]='x j=j+1
as[j]='t j=j+1
as[j]='e j=j+1
as[j]='r j=j+1
as[j]='n j=j+2 SUB=j
as[j]='s j=j+1
as[j]='u j=j+1
as[j]='b j=j+2 ADD=j
as[j]='a j=j+1
as[j]='d j=j+1
as[j]='d j=j+2 CALL=j
as[j]='c j=j+1
as[j]='a j=j+1
as[j]='l j=j+1
as[j]='l j=j+2 PUTCHAR=j
as[j]='p j=j+1
as[j]='u j=j+1
as[j]='t j=j+1
as[j]='c j=j+1
as[j]='h j=j+1
as[j]='a j=j+1
as[j]='r j=j+2 EXIT=j
as[j]='e j=j+1
as[j]='x j=j+1
as[j]='i j=j+1
as[j]='t j=j+2 PRINTF=j
as[j]='p j=j+1
as[j]='r j=j+1
as[j]='i j=j+1
as[j]='n j=j+1
as[j]='t j=j+1
as[j]='f j=j+2 GLOBALDD=j ; :dd 0
as[j]=': j=j+1
as[j]='d j=j+1
as[j]='d j=j+1
as[j]=32 j=j+1
as[j]='0 j=j+2 EXPECTED=j
as[j]='E j=j+1
as[j]='x j=j+1
as[j]='p j=j+1
as[j]='e j=j+1
as[j]='c j=j+1
as[j]='t j=j+1
as[j]='e j=j+1
as[j]='d j=j+2 PUSH=j
as[j]='p j=j+1
as[j]='u j=j+1
as[j]='s j=j+1
as[j]='h j=j+2 POP=j
as[j]='p j=j+1
as[j]='o j=j+1
as[j]='p j=j+2 IMUL=j
as[j]='i j=j+1
as[j]='m j=j+1
as[j]='u j=j+1
as[j]='l j=j+2 CMP=j
as[j]='c j=j+1
as[j]='m j=j+1
as[j]='p j=j+2 SETZ=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='t j=j+1
as[j]='z j=j+2 SETL=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='t j=j+1
as[j]='l j=j+2 JMP=j
as[j]='j j=j+1
as[j]='m j=j+1
as[j]='p j=j+2 ALCOMMAZERO=j
as[j]='A j=j+1
as[j]='L j=j+1
as[j]=', j=j+1
as[j]='0 j=j+2 SETNZ=j
as[j]='s j=j+1
as[j]='e j=j+1
as[j]='t j=j+1
as[j]='n j=j+1
as[j]='z j=j+2 ANDOP=j
as[j]='a j=j+1
as[j]='n j=j+1
as[j]='d j=j+2 OROP=j
as[j]='o j=j+1
as[j]='r j=j+2 XCHG=j
as[j]='x j=j+1
as[j]='c j=j+1
as[j]='h j=j+1
as[j]='g j=j+2 CALLOC=j
as[j]='c j=j+1
as[j]='a j=j+1
as[j]='l j=j+1
as[j]='l j=j+1
as[j]='o j=j+1
as[j]='c j=j+2 GLOBALDQ=j
as[j]=': j=j+1
as[j]='d j=j+1
as[j]='q j=j+1
as[j]=32 j=j+1
as[j]='0 j=j+2 DUPLICATE=j
as[j]='D j=j+1
as[j]='u j=j+1
as[j]='p j=j+1
as[j]='l j=j+1
as[j]='i j=j+1
as[j]='c j=j+1
as[j]='a j=j+1
as[j]='t j=j+1
as[j]='e j=j+2 PARAM=j
as[j]='P j=j+1
as[j]='a j=j+1
as[j]='r j=j+1
as[j]='a j=j+1
as[j]='m j=j+2
as[j]='P j=j+1 PROC=j
as[j]='r j=j+1
as[j]='o j=j+1
as[j]='c j=j+2 ALREADY=j
as[j]='A j=j+1
as[j]='l j=j+1
as[j]='r j=j+1
as[j]='e j=j+1
as[j]='a j=j+1
as[j]='d j=j+1
as[j]='y j=j+2 TOOMANY=j
as[j]='T j=j+1
as[j]='o j=j+1
as[j]='o j=j+1
as[j]=32 j=j+1
as[j]='m j=j+1
as[j]='a j=j+1
as[j]='n j=j+1
as[j]='y j=j+2 VARNOTFOUND=j
as[j]='V j=j+1
as[j]='a j=j+1
as[j]='r j=j+1
as[j]=32 j=j+1
as[j]='n j=j+1
as[j]='o j=j+1
as[j]='t j=j+1
as[j]=32 j=j+1
as[j]='f j=j+1
as[j]='o j=j+1
as[j]='u j=j+1
as[j]='n j=j+1
as[j]='d j=j+2


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_ printbetween(amsg start end) (
  i=start ~(amsg[i]!0 & i<end) ( $amsg[i] i=i+1 )
  $32
)

; Print one
_ print(start) (
  printbetween(as start 9999999)
)
_ printbw(start end) (
  printbetween(as start end)
)

; Print string from s to 0
_ printstr(amsg s) (
  printbetween(amsg s 99999999)
)

; Print two strings
_ printtwo(first second) (
  print(first) print(second)
)

; Print the given token (for debugging)
_ printToken(at) (
  ? (at[0]=CONST) ( $'c $': $32 printstr(at 1) )
  ? (at[0]=CHARCONST) ( $'c $'c $': $32 $'' $at[1] )
  ? (at[0]=VAR) ( $'v $': $32 printstr(at 1) )
  ? (at[0]=SYM) ( $'s $': $32 $at[1])
  ? (at[0]=ERROR) ( $'!)
  ? (at[0]=EOF) ( $'$)
  $10
)

_ fail(at) (
  printtwo(BAD TOKEN) $': $32 printToken(at)
  \ ; exit now
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Registers

RAX=0 RBX=1 RCX=2 RDX=3
EAX=4 EBX=5 ECX=6 EDX=7
RBP=8 RSP=9

_ reg(name) (
  ? (name=RBP) ( $'R $'B $'P ^0)
  ? (name=RSP) ( $'R $'S $'P ^0)
  ? (name<EAX) ( $'R $(name+'A))
  : ( $'E $(name-EAX+'A))
  $'X
)

_ mov() ( $'m $'o $'v $32 )

_ xfer(dest src) (
  mov() reg(dest) $', reg(src) $10
)

_ push(register) (
  print(PUSH) reg(register) $10
)

_ pop(register) (
  print(POP) reg(register) $10
)


_ call(start) (
  printtwo(CALL start) $10
)

_ emitExtern(function) (
 ; extern (function)
 printtwo(EXTERN function) $10
 ; sub rsp, 32
 print(SUB) reg(RSP) $', #32 $10
 call(function)
 ; add rsp, 32
 print(ADD) reg(RSP) $', #32 $10
)

_ emitLabel(labelid)  (
  $'L #labelid $': $10
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Lexer globals
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

loc=0   ; index into text
cc=0  ; current char

_ vadvanceLexer() (
   ? (ainput[loc]!0) ( cc=ainput[loc] )
   : ( cc=0 )
   loc=loc+1
)

_ isNumber(c) (
  ^ (('0-1)<c & c<('9+1))
)

_ isAlpha(c) (
  ? (('a-1)<c & c<('z+1)) (^true)
  ? (('A-1)<c & c<('Z+1)) (^true)
  ^false
)

_ aMakeNumber() (
  at%20
  at[0] = CONST
  at[1] = cc
  i = 2
  vadvanceLexer()
  ~ (cc!0 & isNumber(cc)=true & i<20) (
    at[i] = cc
    i = i + 1
    vadvanceLexer()
  )
  ^at
)

_ aMakeCharConstant() (
  at%3
  vadvanceLexer()  ; skip the tick
  at[0] = CHARCONST
  at[1] = cc
  vadvanceLexer()  ; eat the character
  ^at
)

_ aMakeText() (
  at%20
  at[0] = VAR
  at[1] = cc
  i = 2
  vadvanceLexer()
  ~ (cc!0 & isAlpha(cc)=true & i<20) (
    at[i] = cc
    i = i + 1
    vadvanceLexer()
  )
  ^at
)

_ aMakeSymbol() (
  at%2
  at[0] = SYM
  i=0
  ~ (i < NUMSYMBOLS) ( ; & aSYMBOLS[i]!0) (
    ? (aSYMBOLS[i]=cc) ( ; found it
      at[1]=cc
      vadvanceLexer()
      ^at
    )
    i=i+1
  )
  printtwo(BAD SYMBOL) $': $cc $32 $'( #cc $')
  \ ; exit
)

_ skipWhitespace() (
  more=true
  ~ (more=true) (
    ~ (cc=10|cc=13|cc=32|cc=8) (vadvanceLexer()) ; whitespace
    ? (cc=';) (
       ; skip comment until EOL
       ~ (cc!10 & cc!0) (vadvanceLexer())
    )
    : (more=false)
  )
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; returns array of (up to) 20 ints
; 0 has type: end of file, constant (int), variable, keyword, symbol
; 1 if keyword or symbol: the character
; 1 through 19: variable or constant value (0-terminated)
_ aNextToken() (
  skipWhitespace()
  ? (cc=0) ( at%1 at[0]=EOF ^at) ; end of file
  ? (isNumber(cc)=true) ( ^aMakeNumber() )
  ? (isAlpha(cc)=true) ( ^aMakeText() )
  ? (cc=39) ( ^aMakeCharConstant() )
  ^aMakeSymbol()
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Debugging
;_ printtokens() (
;  vadvanceLexer()
;
;  atemptoken = aNextToken()
;  printToken(atemptoken)
;
;  ~ (atemptoken[0]!EOF) (
;    atemptoken = aNextToken()
;    printToken(atemptoken)
;  )
;)
;printtokens() \


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PARSER
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Current token
atoken%1 ; this allocation will get thrown away


id=0
_ nextLabel() (
  id=id+1
  ^ id
)

_ vadvance() (
  ; $'; $32 printToken(atoken)
  atoken = aNextToken()
)

; Copy the value of the token into a new array.
_ acopyValue() (
  i=0 ~(atoken[i+1]!0) (i=i+1)
  adest%(i+1)
  i=1 ~(atoken[i]!0 & i<20) (adest[i-1]=atoken[i] i=i+1)
  ^adest
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SYMBOL TABLE (ish)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

VarTypeInt=1
VarTypeArr=2

; When not in a proc, the 0th entry will be 0.
aCurrentProcName%1

; Each entry is the hash of a procname
allProcs%101 ; the 0th entry is the length
aNumParams%100 ; # of params for each proc

; Each entry is the hash of the index/4'th param name
aParamNameHashes%400

; We can calculate the offset based on the index.
; This will be reset after each proc
aLocalNameHashes%12

INDEXNOTFOUND=999999

_ lookupParamIndex(aParamName) (
  ? (aCurrentProcName[0]=0) (
    ; not in a proc
    ^INDEXNOTFOUND
  )
  theHash=hash(aParamName)
  procNum=allProcs[0]-1
  ; $'p $'n #procNum $10
  numParams=aNumParams[procNum]
  ; $'N $'P #numParams $10
  i=0 ~(i<numParams) (
    index=procNum*4+i
    ?(aParamNameHashes[index]=theHash) ( ^i )
    i=i+1
  )
  ^INDEXNOTFOUND
)

;; Data segment
aDATA%1000 ndata=0 ; # of bytes of data
intFmtAdded=false

;; Hash values of global data names
aGlobals%100

_ vaddData(asource start end) (
  i=start
  ~ (i<end & asource[i]!0) (aDATA[ndata]=asource[i] i=i+1 ndata=ndata+1)
  aDATA[ndata]=10 ndata=ndata+1
)

aPRIMES%10
aPRIMES[0]=73
aPRIMES[1]=179
aPRIMES[2]=283
aPRIMES[3]=419
aPRIMES[4]=547
aPRIMES[5]=31
aPRIMES[6]=131
aPRIMES[7]=239
aPRIMES[8]=359
aPRIMES[9]=479

_ hash(astring) (
  i=0 pi=0 ; prime index
  r=137 ; result
  ~ (astring[i]!0) (
    r=r*101+astring[i]*aPRIMES[pi]
    pi=pi+1
    ?(pi=10) (pi=0)
    i=i+1
  )
  ^r
)

_ lookupByHash(avalue atable) (
  thehash=hash(avalue)
  nentries=atable[0]
  i=0 ~(i<nentries) (
    ?(atable[i+1]=thehash) (^i) ; found
    i=i+1
  )
  ^INDEXNOTFOUND ; not found
)

; returns index if found, INDEXNOTFOUND if not
; if not found, adds to the end
_ lookupOrAdd(avalue atable) (
  index = lookupByHash(avalue atable)
  ? (index=INDEXNOTFOUND) (
    ; not found, add to the end
    thehash=hash(avalue)
    nentries=atable[0]
    atable[nentries+1]=thehash
    atable[0]=nentries+1
  )
  ^index ; maybe found or not
)

; returns true if found, false if not
; if not found, adds to the end
_ lookupOrAddGlobal(aname) (
  index=lookupOrAdd(aname aGlobals)
  ^(index!INDEXNOTFOUND)
)

; Add a global with the given name and type (int or array)
_ vaddGlobal(aname) (
  ? (lookupOrAddGlobal(aname)=false) (
    ; add _(name)
    aDATA[ndata]='_ ndata=ndata+1
    i=0 ~(aname[i]!0) (aDATA[ndata]=aname[i] i=i+1 ndata=ndata+1)

    ; add :dq 0 or :dd 0
    varType = inferVarType(aname[0])
    ? (varType=VarTypeArr) ( vaddData(as GLOBALDQ 99999999) )
    : (vaddData(as GLOBALDD 99999999))
  )
)


; Print variable: proc, local or global.
_ printVar(avarname) (

  $'[

  found=false
  ? (aCurrentProcName[0]!0) (
    ; we're in a proc, try param
    paramIndex = lookupParamIndex(avarname)
    ? (paramIndex!INDEXNOTFOUND) (
      found=true
      reg(RBP) $'+ #((paramIndex+2)*8)
    )
    : (
      ; not param; look up local
      index = lookupByHash(avarname aLocalNameHashes)
      ? (index!INDEXNOTFOUND) (
        found=true
        reg(RBP) $'- #((index+1)*8)
      )
    )
  )

  ? (found=false) (
    ; not param or local, or not in a proc
    ? (lookupByHash(avarname aGlobals)=INDEXNOTFOUND) (
      ; not in global table, no good.
      $10 print(VARNOTFOUND) $': printstr(avarname 0) $10 fail(atoken)
    )

    $'_ printstr(avarname 0)
  )

  $']
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Expression parsing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

_ expectSymbol(s) (
  ? (isSymbol(s)=true) ( vadvance() ^0 )
  print(EXPECTED) $s $', $32 $'s $'a $'w $32 $atoken[1] $10
  fail(atoken)
)

_ inferVarType(first) (
  ?(first='a | first='A) (^VarTypeArr)
  ^VarTypeInt
)

_ getDestReg(first) (
  ?(first='a | first='A) (^RAX)
  ^EAX
)

_ parseArrayGet(avarname) (
  varType = inferVarType(avarname[0])
  ? (varType!VarTypeArr) (
    ; Not array
    $'N $'A fail(atoken) ^0
  )

  expectSymbol(OPENBRACKET)
  expr()  ; TODO: must be int
  expectSymbol(CLOSEBRACKET)

  ; emit("imul EAX, 4  ; from index to offset")
  print(IMUL) reg(EAX) $', #4 $10

  ; add RAX, ${sym.get.location()}
  print(ADD) reg(RAX) $', printVar(avarname) $10

  ; mov EAX, [RAX]
  mov() reg(EAX) $', $'[ reg(RAX) $'] $10
  ^VarTypeInt
)

_ parseAtom() (
  ? (atoken[0]=CONST) (
    mov() reg(EAX) $', printstr(atoken 1) $10
    vadvance()
    ^VarTypeInt
  )
  ? (atoken[0]=CHARCONST) (
    ; print as a number
    mov() reg(EAX) $', #atoken[1] $10
    vadvance()
    ^VarTypeInt
  )

  ? (atoken[0]=VAR) (
    avar = acopyValue()
    vadvance()

    ; if [ do array dereference
    ? (isSymbol(OPENBRACKET)) (^parseArrayGet(avar))

    ; TODO: if ( do function call

    ; use RAX if array
    destReg=getDestReg(avar[0])

    mov() reg(destReg) $', printVar(avar) $10

    ^(inferVarType(avar[0]))
  )

  ? (isSymbol(OPENPAREN)) (
    expectSymbol(OPENPAREN)
    varType = expr()
    expectSymbol(CLOSEPAREN)
    ^varType
  )

  : ( $'a $'t $'o $'m fail(atoken) )
  ^0
)

_ isSymbol(s) (
  ^(atoken[0]=SYM & atoken[1]=s)
)

_ rhs(op leftType) (
  pop(RBX)
  ? (op=PLUS) ( print(ADD) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=MULT) ( print(IMUL) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=AND) ( print(ANDOP) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=OR) ( print(OROP) reg(EAX) $', reg(EBX) $10 ^leftType)
  ? (op=EQ) (
    ; cmp EBX, EAX
    ; setz AL
    ; and rax, 15
    print(CMP) reg(EBX) $', reg(EAX) $10
    print(SETZ) $'A $'L $10
    print(ANDOP) reg(EAX) $', #15 $10
    ^leftType
  )
  ? (op=NEQ) (
    ; cmp EBX, EAX
    ; setnz AL
    ; and rax, 15
    print(CMP) reg(EBX) $', reg(EAX) $10
    print(SETNZ) $'A $'L $10
    print(ANDOP) reg(EAX) $', #15 $10
    ^leftType
  )
  ? (op=LT) (
    ; cmp EBX, EAX
    ; setl AL
    ; and rax, 15
    print(CMP) reg(EBX) $', reg(EAX) $10
    print(SETL) $'A $'L $10
    print(ANDOP) reg(EAX) $', #15 $10
    ^leftType
  )
  ? (op=MINUS) (
    ; xchg EAX, EBX
    ; sub EAX, EBX
    print(XCHG) reg(EAX) $', reg(EBX) $10
    print(SUB) reg(EAX) $', reg(EBX) $10
    ^leftType
  )
  $'U $'n printtwo(EXPECTED SYMBOL) $op $10 fail(atoken)
)


; Operator Precedences
aPREC%8 j=0
aPREC[j]=MULT j=j+1
aPREC[j]=MINUS j=j+1
aPREC[j]=PLUS j=j+1
aPREC[j]=LT j=j+1
aPREC[j]=NEQ j=j+1
aPREC[j]=EQ j=j+1
aPREC[j]=AND j=j+1
aPREC[j]=OR

_ exprLevel(level) (
  ? (level<0) ( ^parseAtom() )
  leftType = exprLevel(level-1)
  op = aPREC[level]
  ~ (isSymbol(op)) (
    vadvance()
    push(RAX)
    rightType = exprLevel(level - 1)
    rhs(op leftType)
  )
  ^leftType
)

_ expr() (
  ^exprLevel(7)
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parse statements

_ parsePrint() (
  isPrintch = (atoken[1]=PRINTCH)
  vadvance()   ; eat the character

  type = expr() ; ignoring return type for now.

  ? (isPrintch=true) (
    ; mov ecx, eax
    xfer(ECX EAX)
    emitExtern(PUTCHAR)
  )
  : (
    ; add data INT_FMT: db '%d', 0
    ~ (intFmtAdded=false) (
      vaddData(as INTFMT INTFMTEND)
      intFmtAdded=true
    )
    ; mov RCX, INT_FMT
    mov() reg(RCX) $', printbw(INTFMT INTEND) $10
    ; mov edx, eax
    xfer(EDX EAX)

    emitExtern(PRINTF)
  )
  ^0
)

_ parseStop() (
  vadvance()
  call(EXIT)
  ^0
)

_ jmp(labelId) (
  print(JMP) $'L #labelId $10
)

_ parseIf() (
  expectSymbol(IF)
  expr() ; TODO must be int

  elseLabel = nextLabel()
  endIfLabel = nextLabel()

  ; cmp al, 0
  printtwo(CMP ALCOMMAZERO) $10
  ; je Lelselabel
  $'j $'e $32 $'L #elseLabel $10

  expectSymbol(OPENPAREN)
  ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
    statement()
  )
  expectSymbol(CLOSEPAREN)

  hasElse = isSymbol(ELSE)
  ? (hasElse) (
    jmp(endIfLabel)
  )
  emitLabel(elseLabel)

  ? (hasElse) (
    expectSymbol(ELSE)
    expectSymbol(OPENPAREN)
    ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
      statement()
    )
    expectSymbol(CLOSEPAREN)
    emitLabel(endIfLabel)
  )
  ^0
)

_ parseWhile() (
  expectSymbol(WHILE)

  startLabel = nextLabel()
  endLabel = nextLabel()
  emitLabel(startLabel)

  expr()  ; TODO: must be int

  ; cmp al, 0
  printtwo(CMP ALCOMMAZERO) $10
  ; je Llabel
  $'j $'e $32 $'L #endLabel $10

  expectSymbol(OPENPAREN)
  ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
    statement()
  )
  expectSymbol(CLOSEPAREN)

  ; jmp Lend
  jmp(startLabel)
  emitLabel(endLabel)
)

_ strLabel(aname) (
  $'_ printstr(aname 0) $': $10
)

_ registerParam(aParamName) (
  index=lookupParamIndex(aParamName)
  ? (index<INDEXNOTFOUND) (
    ; duplicate param
    printtwo(DUPLICATE PARAM) printstr(aParamName 0) fail(atoken) ^0
  )

  procNum=allProcs[0]-1
  numParams=aNumParams[procNum]
  ? (numParams=4) (
    ; Too many aprams, stop
    printtwo(TOOMANY PARAM) $'i $'n $32 printstr(aCurrentProcName 0) fail(atoken) ^0
  )
  index=procNum*4+numParams
  theHash=hash(aParamName)
  aParamNameHashes[index] = theHash
  aNumParams[procNum] = numParams+1

  vadvance()
)

_ registerProc() (
  index = lookupByHash(aCurrentProcName allProcs)
  ? (index!INDEXNOTFOUND) (
    ; Dupe proc
    printtwo(DUPLICATE PROC) printstr(aCurrentProcName 0) fail(atoken) ^0
  )
  lookupOrAdd(aCurrentProcName allProcs)
)


_ defineProc() (
  ?(aCurrentProcName[0]!0) (
    ; Already in proc
    print(ALREADY) $'i $'n $32 print(PROC) printstr(aCurrentProcName 0) fail(atoken) ^0
  )
  expectSymbol(PROCDEF)

  aCurrentProcName=acopyValue()
  vadvance()

  labelAfterProc = nextLabel()
  jmp(labelAfterProc)

  strLabel(aCurrentProcName)
  registerProc()

  push(RBP)
  mov() reg(RBP) $', reg(RSP) $10

  ; allocate 96 bytes for locals.
  ; sub RSP, 96
  print(SUB) reg(RSP) $', #96 $10

  offset=8
  expectSymbol(OPENPAREN)
  ~(isSymbol(CLOSEPAREN)=false & atoken[0]!EOF) (
    ? (atoken[0]!VAR) ( fail(atoken) ^0 )
    : (
      ; register param name and offset
      aParamName = acopyValue()
      registerParam(aParamName)
    )
    offset = offset + 8
  )
  expectSymbol(CLOSEPAREN)

  expectSymbol(OPENPAREN)
  ~ (atoken[0]!EOF & isSymbol(CLOSEPAREN)=false) (
    statement()
  )
  expectSymbol(CLOSEPAREN)
  $'e $'n $'d strLabel(aCurrentProcName)
  mov() reg(RSP) $', reg(RBP) $10
  pop(RBP)
  $'r $'e $'t $10

  emitLabel(labelAfterProc)

  ; clear/reset symbol tables
  aCurrentProcName[0]=0
  aLocalNameHashes[0]=0
)


_ parseReturn() (
  ? (aCurrentProcName[0]=0) (
    ; not in a proc, this is an error
    $'N $'o $'t $32 $'i $'n $32 print(PROC) $10 fail(atoken)
  )
  
  expectSymbol(RETURN) ; eat the return
  retType = expr() ; TODO: make sure it's the right type

  print(JMP) $'e $'n $'d $'_ printstr(aCurrentProcName 0) $10

  ^retType
)


_ startsWithSymbol() (
  ? ( atoken[1]=IF) ( ^parseIf() )
  ? ( atoken[1]=PRINTCH | atoken[1]=PRINTINT) ( ^parsePrint() )
  ? ( atoken[1]=STOP) ( ^parseStop() )
  ? ( atoken[1]=WHILE) ( ^parseWhile() )
  ? ( atoken[1]=PROCDEF) ( ^defineProc() )
  ? ( atoken[1]=RETURN) ( ^parseReturn() )
  $'s $'w $'s fail(atoken)
)

_ maybeRegisterLocal(avarname) (
  ? (lookupByHash(avarname aGlobals)=INDEXNOTFOUND) (
    ; global not found, maybe local or param
    ? (aCurrentProcName[0]=0) (
      ; not in a proc, this is an error
      print(VARNOTFOUND) $': printstr(avarname 0) $10 fail(atoken)
    )
    index = lookupParamIndex(avarname)
    ? (index=INDEXNOTFOUND) (
      ; register local
      lookupOrAdd(avarname aLocalNameHashes)
    )
  )
)


_ vRegisterVariable(avarname) (
  ? (aCurrentProcName[0]=0) (
    ; we're not in a proc, add global
    vaddGlobal(avarname)
  )
  : (
    ; in a proc, register local
    maybeRegisterLocal(avarname)
  )
)


_ varAssignment(avarname) (
  vRegisterVariable(avarname)
  vadvance() ; eat the =

  expr() ; TODO: check the return type

  srcReg=getDestReg(avarname[0])
  mov() printVar(avarname) $', reg(srcReg) $10
)

_ parseAllocArray(avarname) (
  ; TODO: check vartype of avarname
  vRegisterVariable(avarname)
  vadvance() ; eat the %

  expr()  ; TODO: must be int

  ; emit("imul EAX, 4")
  print(IMUL) reg(EAX) $', #4 $10
  ; emit("mov ECX, EAX")
  xfer(ECX EAX)
  ; emit("mov EDX, 1")
  mov() reg(EDX) $', #1 $10
  ; emitExtern("calloc")
  emitExtern(CALLOC)

  ; emit(s"mov ${sym.location()}, RAX")
  mov() printVar(avarname) $', reg(RAX) $10
)


_ parseArraySet(avarname) (
  expectSymbol(OPENBRACKET)
  indexType = expr()   ; TODO must be int
  expectSymbol(CLOSEBRACKET)

  expectSymbol(EQ)

  ; emit("imul EAX, 4  ; from index to offset")
  print(IMUL) reg(EAX) $', #4 $10
  ; emit(s"add RAX, ${sym.get.location()}  ; absolute location")
  print(ADD) reg(RAX) $', printVar(avarname) $10
  ; emit("push RAX  ; array location")
  push(RAX)

  exprType = expr()

  pop(RBX)
  ; emit("mov DWORD [RBX], EAX  ; assign array location")
  mov() $'[ reg(RBX) $'] $', reg(EAX) $10
)


_ startsWithVar() (
  aname=acopyValue()
  vadvance()
  ? (isSymbol(EQ)) ( varAssignment(aname) )
  ? (isSymbol(LENGTH)) ( ^parseAllocArray(aname) )
  ? (isSymbol(OPENBRACKET)) ( ^parseArraySet(aname) )

  ; TODO: if ( do function call
)


_ statement() (
  ? (atoken[0]=SYM) ( ^startsWithSymbol() )
  ? (atoken[0]=VAR) ( ^startsWithVar() )
  ? (atoken[0]=EOF) ( ^0 )
  $'s fail(atoken)
)


_ statements() (
  ~ (atoken[0]!EOF) (
    statement()
  )
)

_ parse() (
  ; $'; printstr(ainput 0)

  vadvanceLexer() ; prime the lexer
  vadvance() ; prime the parser

  ; global main
  printstr(as HEADER) $10
  ; section .text
  printtwo(SECTION DOTTEXT) $10

  printstr(as MAIN) $': $10

  statements()

  ; call exit
  emitExtern(EXIT)
  ; ret
  $'r $'e $'t $10

  ? (ndata!0) (
    $10
    ; section .data
    printtwo(SECTION DOTDATA) $10
    printstr(aDATA 0)
  )
)

parse()

